services: 

  redis:
    image: redis:8.4-alpine
    container_name: printing_marketplace_redis
    restart: unless-stopped
    env_file:
      - .env
    ports:
      - "6379:6379"
    # 1. Enable Persistence (AOF)
    # 2. Set password (requirepass)
    # 3. Limit memory (e.g., 256mb) and set eviction policy
    command: >
      redis-server 
      --appendonly yes
      --requirepass ${REDIS_PASSWORD}
      --maxmemory 256mb 
      --maxmemory-policy volatile-lru
    volumes:
      - redis_data:/data
    networks:
      - printing_service

  postgres: 
    restart: unless-stopped
    image: postgres:15
    container_name: printing_marketplace_db
    env_file:
      - .env
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_AUTH_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./database/create_database.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - printing_service

  authorization: 
    build: ./auth
    container_name: printing_marketplace_authorization
    restart: unless-stopped
    env_file:
      - .env
    environment:
      KC_BOOTSTRAP_ADMIN_USERNAME: ${AUTHORIZATION_ADMIN_USERNAME}     # Super admin username
      KC_BOOTSTRAP_ADMIN_PASSWORD: ${AUTHORIZATION_ADMIN_PASSWORD}     # Super admin password
      KC_HOSTNAME: ${AUTHORIZATION_URL}                                # Important for browser redirection
      KC_HOSTNAME_PORT: ${AUTHORIZATION_PORT}                          # Important for browser redirection
      KC_PROXY_HEADERS: xforwarded

      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/${POSTGRES_AUTH_DB}
      KC_DB_USERNAME: ${POSTGRES_USER}
      KC_DB_PASSWORD: ${POSTGRES_PASSWORD}
      KC_CACHE_STACK: udp
      
      KC_HOSTNAME_STRICT: false
      KC_HTTP_ENABLED: true
    command: start
    ports:
      - "4080:8080"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - printing_service

  nats:
    image: nats:2.12.2-alpine
    container_name: nats
    # Enable JetStream (-js) and set storage directory (-sd)
    command: "-js -sd /data -m 8222"
    ports:
      - "4222:4222" # Client Port (Services connect here)
      - "8222:8222" # Monitoring Dashboard (HTTP)
    volumes:
      - nats_data:/data # Persist streams here so they survive restarts
    networks:
      - printing_service

  minio:
    image: minio/minio:RELEASE.2025-09-07T16-13-09Z
    container_name: minio
    # Start server on /data, expose console on port 9001
    command: server /data --console-address ":9001"
    ports:
      - "9000:9000" # API Port (Go & React connect here)
      - "9001:9001" # Web Console (Browser UI)
    env_file:
      - .env
    volumes:
      - minio_data:/data # Persist files on disk
    networks:
      - printing_service

    # --- 2. The Setup Script (Runs once) ---
  createbuckets:
      image: minio/mc
      depends_on:
        - minio
      # This script waits for MinIO to start, then creates your buckets
      networks:
        - printing_service
      entrypoint:
      - /bin/sh
      - -c
      - |
        # 1. Wait for MinIO to be ready
        until /usr/bin/mc alias set myminio http://minio:9000 ${MINIO_ROOT_USER} ${MINIO_ROOT_PASSWORD}; do
          echo 'Waiting for MinIO...'
          sleep 1
        done

        # 2. Create 'incoming-files' (Quarantine)
        /usr/bin/mc mb --ignore-existing myminio/incoming-files

        # 3. Create 'public-files' (Assets)
        /usr/bin/mc mb --ignore-existing myminio/public-files

        # 4. Make 'public-files' readable by the world
        /usr/bin/mc anonymous set download myminio/public-files

        echo "Ensuring Service Account exists..."
        
        # Try to add the user/key. If it exists, this might error, so we allow failure or check first.
        # Ideally, MinIO 'mc admin user add' creates a user. 
        
        /usr/bin/mc admin user add myminio ${GATEWAY_S3_ACCESS_KEY_ID} ${GATEWAY_S3_SECRET_ACCESS_KEY}
        /usr/bin/mc admin user add myminio ${VALIDATION_WORKER_S3_ACCESS_KEY_ID} ${VALIDATION_WORKER_S3_SECRET_ACCESS_KEY}
        
        # Grant read/write permission to this user
        /usr/bin/mc admin policy attach myminio readwrite --user ${GATEWAY_S3_ACCESS_KEY_ID}
        /usr/bin/mc admin policy attach myminio readwrite --user ${VALIDATION_WORKER_S3_ACCESS_KEY_ID}

        echo 'MinIO Setup Complete'
        exit 0
  # nats-exporter:
  #   image: natsio/prometheus-nats-exporter:latest
  #   command: -connz -routez -subz -varz -prefix=nats http://nats:8222
  #   ports:
  #     - "7777:7777"
  #   depends_on:
  #     - nats
  #   networks:
  #     - printing_service

  # prometheus:
  #   image: prom/prometheus:latest
  #   volumes:
  #     - ./prometheus.yml:/etc/prometheus/prometheus.yml
  #   ports:
  #     - "9090:9090"
  #   depends_on:
  #     - nats-exporter
  #   networks:
  #     - printing_service

  # grafana:
  #   image: grafana/grafana:latest
  #   ports:
  #     - "3001:3000" # Mapped to 3001 to avoid conflicts
  #   environment:
  #     - GF_SECURITY_ADMIN_PASSWORD=admin
  #   depends_on:
  #     - prometheus
  #   volumes:
  #     - grafana_data:/var/lib/grafana
  #   networks:
  #     - printing_service

volumes:
  redis_data:
    driver: local
  minio_data:
    driver: local 
  nats_data:
    driver: local
  pgdata:
    driver: local
  grafana_data:
    driver: local
networks:
  printing_service:
    external: true