// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package gateway

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createListing = `-- name: CreateListing :one
INSERT INTO listings (
    user_id, seller_name, seller_username, title, description, price_min_unit, currency, categories, license, client_id, trace_id, thumbnail_path, status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, user_id, seller_name, seller_username, title, description, price_min_unit, currency, categories, license, client_id, trace_id, thumbnail_path, last_indexed_at, status, created_at, updated_at, deleted_at
`

type CreateListingParams struct {
	UserID         pgtype.UUID       `json:"user_id"`
	SellerName     string            `json:"seller_name"`
	SellerUsername string            `json:"seller_username"`
	Title          string            `json:"title"`
	Description    pgtype.Text       `json:"description"`
	PriceMinUnit   pgtype.Numeric    `json:"price_min_unit"`
	Currency       string            `json:"currency"`
	Categories     []string          `json:"categories"`
	License        string            `json:"license"`
	ClientID       string            `json:"client_id"`
	TraceID        string            `json:"trace_id"`
	ThumbnailPath  pgtype.Text       `json:"thumbnail_path"`
	Status         NullListingStatus `json:"status"`
}

// Note: 'categories' param must be passed as a string slice (text[]) in Go
func (q *Queries) CreateListing(ctx context.Context, arg CreateListingParams) (Listing, error) {
	row := q.db.QueryRow(ctx, createListing,
		arg.UserID,
		arg.SellerName,
		arg.SellerUsername,
		arg.Title,
		arg.Description,
		arg.PriceMinUnit,
		arg.Currency,
		arg.Categories,
		arg.License,
		arg.ClientID,
		arg.TraceID,
		arg.ThumbnailPath,
		arg.Status,
	)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SellerName,
		&i.SellerUsername,
		&i.Title,
		&i.Description,
		&i.PriceMinUnit,
		&i.Currency,
		&i.Categories,
		&i.License,
		&i.ClientID,
		&i.TraceID,
		&i.ThumbnailPath,
		&i.LastIndexedAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createListingFile = `-- name: CreateListingFile :one
INSERT INTO listing_files (
    listing_id, file_path, file_type, file_size, metadata, status
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, listing_id, file_path, file_type, file_size, metadata, status, error_message, is_generated, source_file_id, created_at, updated_at, deleted_at
`

type CreateListingFileParams struct {
	ListingID pgtype.UUID    `json:"listing_id"`
	FilePath  string         `json:"file_path"`
	FileType  FileType       `json:"file_type"`
	FileSize  pgtype.Int8    `json:"file_size"`
	Metadata  []byte         `json:"metadata"`
	Status    NullFileStatus `json:"status"`
}

func (q *Queries) CreateListingFile(ctx context.Context, arg CreateListingFileParams) (ListingFile, error) {
	row := q.db.QueryRow(ctx, createListingFile,
		arg.ListingID,
		arg.FilePath,
		arg.FileType,
		arg.FileSize,
		arg.Metadata,
		arg.Status,
	)
	var i ListingFile
	err := row.Scan(
		&i.ID,
		&i.ListingID,
		&i.FilePath,
		&i.FileType,
		&i.FileSize,
		&i.Metadata,
		&i.Status,
		&i.ErrorMessage,
		&i.IsGenerated,
		&i.SourceFileID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getFilesByListingID = `-- name: GetFilesByListingID :many
SELECT id, listing_id, file_path, file_type, file_size, metadata, status, error_message, is_generated, source_file_id, created_at, updated_at, deleted_at FROM listing_files 
WHERE listing_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetFilesByListingID(ctx context.Context, listingID pgtype.UUID) ([]ListingFile, error) {
	rows, err := q.db.Query(ctx, getFilesByListingID, listingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingFile
	for rows.Next() {
		var i ListingFile
		if err := rows.Scan(
			&i.ID,
			&i.ListingID,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.Metadata,
			&i.Status,
			&i.ErrorMessage,
			&i.IsGenerated,
			&i.SourceFileID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingByID = `-- name: GetListingByID :one
SELECT id, user_id, seller_name, seller_username, title, description, price_min_unit, currency, categories, license, client_id, trace_id, thumbnail_path, last_indexed_at, status, created_at, updated_at, deleted_at FROM listings 
    WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetListingByID(ctx context.Context, id pgtype.UUID) (Listing, error) {
	row := q.db.QueryRow(ctx, getListingByID, id)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SellerName,
		&i.SellerUsername,
		&i.Title,
		&i.Description,
		&i.PriceMinUnit,
		&i.Currency,
		&i.Categories,
		&i.License,
		&i.ClientID,
		&i.TraceID,
		&i.ThumbnailPath,
		&i.LastIndexedAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getListingByIDAdmin = `-- name: GetListingByIDAdmin :one
SELECT id, user_id, seller_name, seller_username, title, description, price_min_unit, currency, categories, license, client_id, trace_id, thumbnail_path, last_indexed_at, status, created_at, updated_at, deleted_at FROM listings WHERE id = $1
`

func (q *Queries) GetListingByIDAdmin(ctx context.Context, id pgtype.UUID) (Listing, error) {
	row := q.db.QueryRow(ctx, getListingByIDAdmin, id)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SellerName,
		&i.SellerUsername,
		&i.Title,
		&i.Description,
		&i.PriceMinUnit,
		&i.Currency,
		&i.Categories,
		&i.License,
		&i.ClientID,
		&i.TraceID,
		&i.ThumbnailPath,
		&i.LastIndexedAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getListingsByUserID = `-- name: GetListingsByUserID :many
SELECT 
    l.id, l.user_id, l.seller_name, l.seller_username, l.title, l.description, l.price_min_unit, l.currency, l.categories, l.license, l.client_id, l.trace_id, l.thumbnail_path, l.last_indexed_at, l.status, l.created_at, l.updated_at, l.deleted_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', f.id,
                'file_path', f.file_path,
                'file_type', f.file_type,
                'status', f.status,
                'error_message', f.error_message,
                'is_generated', f.is_generated,
                'source_file_id', f.source_file_id,
                'size', f.file_size,
                'metadata', f.metadata
            )
        ) FILTER (WHERE f.id IS NOT NULL), 
        '[]'
    )::jsonb AS files
FROM listings l
LEFT JOIN listing_files f ON l.id = f.listing_id AND f.deleted_at IS NULL
WHERE l.user_id = $1 AND l.deleted_at IS NULL
GROUP BY l.id
ORDER BY l.created_at DESC
`

type GetListingsByUserIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	UserID         pgtype.UUID        `json:"user_id"`
	SellerName     string             `json:"seller_name"`
	SellerUsername string             `json:"seller_username"`
	Title          string             `json:"title"`
	Description    pgtype.Text        `json:"description"`
	PriceMinUnit   pgtype.Numeric     `json:"price_min_unit"`
	Currency       string             `json:"currency"`
	Categories     []string           `json:"categories"`
	License        string             `json:"license"`
	ClientID       string             `json:"client_id"`
	TraceID        string             `json:"trace_id"`
	ThumbnailPath  pgtype.Text        `json:"thumbnail_path"`
	LastIndexedAt  pgtype.Timestamptz `json:"last_indexed_at"`
	Status         NullListingStatus  `json:"status"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	DeletedAt      pgtype.Timestamptz `json:"deleted_at"`
	Files          []byte             `json:"files"`
}

func (q *Queries) GetListingsByUserID(ctx context.Context, userID pgtype.UUID) ([]GetListingsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getListingsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListingsByUserIDRow
	for rows.Next() {
		var i GetListingsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SellerName,
			&i.SellerUsername,
			&i.Title,
			&i.Description,
			&i.PriceMinUnit,
			&i.Currency,
			&i.Categories,
			&i.License,
			&i.ClientID,
			&i.TraceID,
			&i.ThumbnailPath,
			&i.LastIndexedAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Files,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingsForSync = `-- name: GetListingsForSync :many
SELECT id, user_id, seller_name, seller_username, title, description, price_min_unit, currency, categories, license, client_id, trace_id, thumbnail_path, last_indexed_at, status, created_at, updated_at, deleted_at FROM listings
WHERE (last_indexed_at IS NULL OR updated_at > last_indexed_at)
LIMIT $1
`

// Finds all listings that are new OR have been updated since the last sync
func (q *Queries) GetListingsForSync(ctx context.Context, limit int32) ([]Listing, error) {
	rows, err := q.db.Query(ctx, getListingsForSync, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Listing
	for rows.Next() {
		var i Listing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SellerName,
			&i.SellerUsername,
			&i.Title,
			&i.Description,
			&i.PriceMinUnit,
			&i.Currency,
			&i.Categories,
			&i.License,
			&i.ClientID,
			&i.TraceID,
			&i.ThumbnailPath,
			&i.LastIndexedAt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markListingAsIndexed = `-- name: MarkListingAsIndexed :exec
UPDATE listings 
SET last_indexed_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// The worker calls this AFTER successfully pushing to Typesense
func (q *Queries) MarkListingAsIndexed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markListingAsIndexed, id)
	return err
}

const softDeleteFile = `-- name: SoftDeleteFile :exec
UPDATE listing_files
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteFile(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteFile, id)
	return err
}

const softDeleteListing = `-- name: SoftDeleteListing :one
UPDATE listings 
    SET deleted_at = CURRENT_TIMESTAMP
    WHERE id = $1 AND user_id = $2 -- Ensure user owns it before deleting
    RETURNING id, user_id, seller_name, seller_username, title, description, price_min_unit, currency, categories, license, client_id, trace_id, thumbnail_path, last_indexed_at, status, created_at, updated_at, deleted_at
`

type SoftDeleteListingParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) SoftDeleteListing(ctx context.Context, arg SoftDeleteListingParams) (Listing, error) {
	row := q.db.QueryRow(ctx, softDeleteListing, arg.ID, arg.UserID)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SellerName,
		&i.SellerUsername,
		&i.Title,
		&i.Description,
		&i.PriceMinUnit,
		&i.Currency,
		&i.Categories,
		&i.License,
		&i.ClientID,
		&i.TraceID,
		&i.ThumbnailPath,
		&i.LastIndexedAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateListing = `-- name: UpdateListing :one
UPDATE listings SET
    title = $2,
    description = $3,
    price_min_unit = $4,
    currency = $5,
    categories = $6,
    license = $7,
    client_id = $8,
    trace_id = $9,
    thumbnail_path = $10,
    status = $11
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, user_id, seller_name, seller_username, title, description, price_min_unit, currency, categories, license, client_id, trace_id, thumbnail_path, last_indexed_at, status, created_at, updated_at, deleted_at
`

type UpdateListingParams struct {
	ID            pgtype.UUID       `json:"id"`
	Title         string            `json:"title"`
	Description   pgtype.Text       `json:"description"`
	PriceMinUnit  pgtype.Numeric    `json:"price_min_unit"`
	Currency      string            `json:"currency"`
	Categories    []string          `json:"categories"`
	License       string            `json:"license"`
	ClientID      string            `json:"client_id"`
	TraceID       string            `json:"trace_id"`
	ThumbnailPath pgtype.Text       `json:"thumbnail_path"`
	Status        NullListingStatus `json:"status"`
}

func (q *Queries) UpdateListing(ctx context.Context, arg UpdateListingParams) (Listing, error) {
	row := q.db.QueryRow(ctx, updateListing,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.PriceMinUnit,
		arg.Currency,
		arg.Categories,
		arg.License,
		arg.ClientID,
		arg.TraceID,
		arg.ThumbnailPath,
		arg.Status,
	)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SellerName,
		&i.SellerUsername,
		&i.Title,
		&i.Description,
		&i.PriceMinUnit,
		&i.Currency,
		&i.Categories,
		&i.License,
		&i.ClientID,
		&i.TraceID,
		&i.ThumbnailPath,
		&i.LastIndexedAt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
