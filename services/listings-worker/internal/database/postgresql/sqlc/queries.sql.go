// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package listings_worker

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFilesByListingID = `-- name: GetFilesByListingID :many
SELECT id, listing_id, file_path, file_type, file_size, metadata, status, error_message, is_generated, source_file_id, created_at, updated_at, deleted_at FROM listing_files 
WHERE listing_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetFilesByListingID(ctx context.Context, listingID pgtype.UUID) ([]ListingFile, error) {
	rows, err := q.db.Query(ctx, getFilesByListingID, listingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingFile
	for rows.Next() {
		var i ListingFile
		if err := rows.Scan(
			&i.ID,
			&i.ListingID,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.Metadata,
			&i.Status,
			&i.ErrorMessage,
			&i.IsGenerated,
			&i.SourceFileID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingByID = `-- name: GetListingByID :one
SELECT 
    id, 
    seller_name, 
    seller_username, 
    user_id, 
    title, 
    description,
    price_min_unit,
    currency,
    categories,
    license,
    thumbnail_path,
    created_at
FROM listings 
WHERE id = $1 AND deleted_at IS NULL
`

type GetListingByIDRow struct {
	ID             pgtype.UUID        `json:"id"`
	SellerName     string             `json:"seller_name"`
	SellerUsername string             `json:"seller_username"`
	UserID         pgtype.UUID        `json:"user_id"`
	Title          string             `json:"title"`
	Description    pgtype.Text        `json:"description"`
	PriceMinUnit   pgtype.Numeric     `json:"price_min_unit"`
	Currency       string             `json:"currency"`
	Categories     []string           `json:"categories"`
	License        string             `json:"license"`
	ThumbnailPath  pgtype.Text        `json:"thumbnail_path"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetListingByID(ctx context.Context, id pgtype.UUID) (GetListingByIDRow, error) {
	row := q.db.QueryRow(ctx, getListingByID, id)
	var i GetListingByIDRow
	err := row.Scan(
		&i.ID,
		&i.SellerName,
		&i.SellerUsername,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.PriceMinUnit,
		&i.Currency,
		&i.Categories,
		&i.License,
		&i.ThumbnailPath,
		&i.CreatedAt,
	)
	return i, err
}

const markListingAsIndexed = `-- name: MarkListingAsIndexed :exec
UPDATE listings 
SET last_indexed_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// The worker calls this AFTER successfully pushing to Typesense
func (q *Queries) MarkListingAsIndexed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markListingAsIndexed, id)
	return err
}
