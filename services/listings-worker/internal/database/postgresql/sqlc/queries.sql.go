// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package listings_worker

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getFilesByListingID = `-- name: GetFilesByListingID :many
SELECT id, listing_id, file_path, file_type, file_size, metadata, status, error_message, is_generated, source_file_id, created_at, updated_at, deleted_at FROM listing_files 
WHERE listing_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetFilesByListingID(ctx context.Context, listingID pgtype.UUID) ([]ListingFile, error) {
	rows, err := q.db.Query(ctx, getFilesByListingID, listingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListingFile
	for rows.Next() {
		var i ListingFile
		if err := rows.Scan(
			&i.ID,
			&i.ListingID,
			&i.FilePath,
			&i.FileType,
			&i.FileSize,
			&i.Metadata,
			&i.Status,
			&i.ErrorMessage,
			&i.IsGenerated,
			&i.SourceFileID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingByID = `-- name: GetListingByID :one
SELECT 
    id, seller_id, seller_name, seller_username, seller_verified, title, description, price_min_unit, currency, categories, license, client_id, trace_id, thumbnail_path, last_indexed_at, status, is_remixing_allowed, parent_listing_id, is_physical, total_weight_grams, is_assembly_required, is_hardware_required, hardware_required, is_multicolor, dimensions_mm, recommended_nozzle_temp_c, recommended_materials, is_ai_generated, ai_model_name, likes_count, downloads_count, comments_count, is_sale_active, sale_price, sale_name, sale_end_timestamp, seller_rating_average, seller_total_ratings, seller_total_sales, is_nsfw, created_at, updated_at, deleted_at
FROM listings 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetListingByID(ctx context.Context, id pgtype.UUID) (Listing, error) {
	row := q.db.QueryRow(ctx, getListingByID, id)
	var i Listing
	err := row.Scan(
		&i.ID,
		&i.SellerID,
		&i.SellerName,
		&i.SellerUsername,
		&i.SellerVerified,
		&i.Title,
		&i.Description,
		&i.PriceMinUnit,
		&i.Currency,
		&i.Categories,
		&i.License,
		&i.ClientID,
		&i.TraceID,
		&i.ThumbnailPath,
		&i.LastIndexedAt,
		&i.Status,
		&i.IsRemixingAllowed,
		&i.ParentListingID,
		&i.IsPhysical,
		&i.TotalWeightGrams,
		&i.IsAssemblyRequired,
		&i.IsHardwareRequired,
		&i.HardwareRequired,
		&i.IsMulticolor,
		&i.DimensionsMm,
		&i.RecommendedNozzleTempC,
		&i.RecommendedMaterials,
		&i.IsAiGenerated,
		&i.AiModelName,
		&i.LikesCount,
		&i.DownloadsCount,
		&i.CommentsCount,
		&i.IsSaleActive,
		&i.SalePrice,
		&i.SaleName,
		&i.SaleEndTimestamp,
		&i.SellerRatingAverage,
		&i.SellerTotalRatings,
		&i.SellerTotalSales,
		&i.IsNsfw,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const markListingAsIndexed = `-- name: MarkListingAsIndexed :exec
UPDATE listings 
SET last_indexed_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// The worker calls this AFTER successfully pushing to Typesense
func (q *Queries) MarkListingAsIndexed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markListingAsIndexed, id)
	return err
}
